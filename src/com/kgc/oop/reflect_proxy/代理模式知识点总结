代理模式：代理模式：为其他对象提供一种代理以控制对这个对象的访问。
         说白了就是"真实对象"的代表，在访问对象时引入一定程度的间接性，因为这种间接性可以附加多种用途。
         代理，可以理解为 我们生活中的代购、律师、中介。把对象不必要的步骤交给其他对象来做，使本对向更加专注的完成某项工作。

静态代理模式：
        静态代理模式优点：
            分解角色功能，使真实角色（房东）更加纯粹
            真正的租房是由中介完成的，使业务集中在中介类，业务更加纯粹
            中介可以帮助房东完成各项事务，便于扩展业务，而且业务发生改变时便于集中管理
        缺点：
            每有一个角色就要有一个代理，代码量翻倍且大多冗余

动态代理模式：代理类在程序运行时创建的代理方式被称为动态代理。
            也就是说，代理类并不需要在Java代码中定义，而是在运行时动态生成的。

        两种方式：jdk动态代理和cglib动态代理

        1、jdk动态代理（需要接口）
              jdk动态代理是由java内部的反射机制来实现的。 JDK动态代理所用到的代理类在程序调用到代理类
              对象时才由JVM真正创建，JVM根据传进来的 业务实现类对象 以及 方法名 ，动态地创建了一个代理
              类的class文件并被字节码引擎执行，然后通过该代理类对象进行方法调用。
              JDK动态代理的代理对象在创建时，需要使用业务实现类所实现的接口作为参数（因为在后面代理方法
              时需要根据接口内的方法名进行调用）。如果业务实现类是没有实现接口而是直接定义业务方法的话，
              就无法使用JDK动态代理了。并且，如果业务实现类中新增了接口中没有的方法，这些方法是无法被代
              理的（因为无法被调用）。这是jdk动态代理的局限性。

        2、cglib框架动态代理
              cglib是针对类来实现代理的，原理是对指定的业务类生成一个子类，并覆盖其中业务方法实现代理。
              因为采用的是继承，所以不能对final修饰的类进行代理。

        最后总结：
        1、一个代理模式主要有几个角色：抽象角色、具体角色（被代理角色）、代理角色、场景类（调用代理角色）
        2、静态代理，首先定义一个接口，然后代理角色和被代理角色都要实现这个接口，最后调用方调用代理角色的方法。缺点是都要实现接口，扩展性不好。
        3、动态代理四步骤：建抽象角色、建真实角色、创建动态中介类（jdk或cglib动态代理）、场景类动态生成代理类
        4、jdk动态代理实现接口InvocationHandler来创建动态中介类
        5、cglib是针对类来实现代理的，原理是对指定的业务类生成一个子类，并覆盖其中业务方法实现代理
        6、jdk动态代理只能针对接口来生成代理类(从Proxy的接口方法newProxyInstance(classLoader,interfaces,invocationHandler)可以看出)；cglib采用底层的字节码技术，针对类来实现代理；